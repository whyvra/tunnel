@using Microsoft.Extensions.DependencyInjection

@inherits ComponentBase
@typeparam TModel

@inject IServiceProvider services

<form>
    @foreach (var field in FormModel.Fields.Where(x => x is Input input && !input.IsHidden).Select(x => (Input)x))
    {
        @if (field is TextArea area)
        {
            <div class="field">
                <label for="@(field.Name)">@(field.DisplayName)</label>
                <div class="control">
                    <textarea id="@(field.Name)" class="textarea has-fixed-size @(FormViewMode == FormViewMode.Readonly ? "is-static" : "")"
                        placeholder="@(field.DisplayName)" value="@(field.Getter(FormModel.DataModel) ?? string.Empty)"
                        @onchange="@(async (e) => await HandleChange(field, e))" readonly="@(FormViewMode == FormViewMode.Readonly)"
                        rows="@(area.Rows.HasValue ? $"{area.Rows.Value}" : "")"
                        columns="@(area.Columns.HasValue ? $"{area.Columns.Value}" : "")"
                        @onfocusout="@(() => TriggerValidation(field))">
                    </textarea>
                    @if (_isValidationEnabled)
                    {
                        <ValidationMessage Messages="@field.ValidationMessages" />
                    }
                </div>
            </div>
        }
        else if (field is TagsInput tag)
        {
            <div class="field">
                <label for="@(field.Name)">@(field.DisplayName)</label>
                <div class="control" @onfocusout="@(() => TriggerValidation(field))">
                    <BulmaTagsInput
                        Data="@(field.Getter(FormModel.DataModel) as IEnumerable<string>)"
                        EmptyValue="@tag.EmptyValue"
                        IsReadOnly="@(FormViewMode == FormViewMode.Readonly)"
                        Placeholder="@(tag.DisplayName)"
                        DataChanged="@((tags) => tag.Setter(FormModel.DataModel, tags))" />
                    @if (_isValidationEnabled)
                    {
                        <ValidationMessage Messages="@field.ValidationMessages" />
                    }
                </div>
            </div>
        }
        else if (field is Checkbox checkbox)
        {
            <div class="field">
                <div class="control">
                    <label>
                        <input type="checkbox" class="checkbox"
                            checked="@field.Getter(FormModel.DataModel)"
                            @onchange="@(e => HandleCheckbox(checkbox, e))" >
                        @checkbox.DisplayName 
                    </label>
                </div>
            </div>
        }
        else {
            <div class="field">
                <label for="@(field.Name)">@(field.DisplayName)</label>
                <p class="control @(field.Icon != null ? "has-icons-left" : "")">
                    <input id="@(field.Name)" class="input @(FormViewMode == FormViewMode.Readonly ? "is-static" : "")" type="text"
                        placeholder="@(field.DisplayName)" value="@(field.Getter(FormModel.DataModel))"
                        @onchange="@(async (e) => await HandleChange(field, e))" readonly="@(FormViewMode == FormViewMode.Readonly)"
                        @onfocusout="@(() => TriggerValidation(field))" >
                    @if (field.Icon != null)
                    {
                        <span class="icon is-left">
                            <i class="fas fa-@(field.Icon)"></i>
                        </span>
                    }
                    @if (_isValidationEnabled)
                    {
                        <ValidationMessage Messages="@field.ValidationMessages" />
                    }
                </p>
            </div>
        }
        
    }
    <div class="field is-grouped">
        @foreach (var button in FormModel.Fields.Where(x => x is Button).Select(x => (Button)x))
        {
            <div class="control">
                <button class="button @(string.Join(" ", button.Classes))" @onclick:preventDefault
                    @onclick="@(async (e) => await HandleClick(button, e))">
                    <span class="icon">
                        <i class="fas fa-@(button.Icon)"></i>
                    </span>
                    <span>@(button.Name)</span>
                </button>
            </div>
        }
    </div>
</form>

@code
{
    private IValidator<TModel> _validator;
    private bool _isValidationEnabled;

    [Parameter]
    public FormModel<TModel> FormModel { get; set; }

    [Parameter]
    public FormViewMode FormViewMode { get; set; }

    protected override void OnInitialized()
    {
        _validator = services.GetService<IValidator<TModel>>();
        _isValidationEnabled = !(_validator == null);
    }

    public void Validate()
    {
        FormModel.Fields
            .Where(x => x is Input)
            .Select(x => (Input) x)
            .ToList()
            .ForEach(TriggerValidation);
    }

    private async Task HandleChange(Input input, ChangeEventArgs e)
    {
        // Update data model
        input.Setter(FormModel.DataModel, e.Value.ToString().Trim());

        // Fire off async handlers
        var asyncHandler = input.OnChangeAsyncHandler?.InvokeAllAsync(this, e) ?? Task.CompletedTask;

        // Fire off synchronous handlers
        var handler = input.OnChangeHandler;
        handler?.Invoke(this, e);

        // Wait for async handlers to complete
        await asyncHandler;
    }

    private void HandleCheckbox(Checkbox checkbox, ChangeEventArgs e)
    {
        // Update model with current value
        var isChecked = (bool) e.Value;
        checkbox.Setter(FormModel.DataModel, isChecked);

        if (checkbox.FieldsToHideFunc != null)
        {
            // Hide selected fields
            FormModel.Fields
                .Where(x => x is Input input && checkbox.FieldsToHideFunc(input))
                .Select(x => (Input) x)
                .ToList()
                .ForEach(x => x.IsHidden = isChecked);
        }
    }

    private async Task HandleClick(Button button, MouseEventArgs e)
    {
        // Fire off async handlers
        var asyncHandler = button.OnClickAsyncHandler?.InvokeAllAsync(this, e) ?? Task.CompletedTask;

        // Fire off synchronous handlers
        var handler = button.OnClickHandler;
        handler?.Invoke(this, e);

        // Wait for async handlers to complete
        await asyncHandler;
    }

    private void TriggerValidation(Input field)
    {
        if (_isValidationEnabled)
        {
            var result = _validator.Validate(FormModel.DataModel);

            field.ValidationMessages = result.Errors
                .Where(x => x.PropertyName.Equals(field.ValidationPath))
                .Select(x => x.ErrorMessage);
        }
    }
}